<html>
<head>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.js" type="text/javascript"></script>

    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.8/dist/umd/popper.min.js" integrity="sha384-I7E8VVD/ismYTF4hNIPjVp/Zjvgyol6VFvRkX/vR+Vc4jQkC+hVqc2pM8ODewa9r" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.min.js" integrity="sha384-0pUGZvbkm6XF6gxjEnlmuGrJXVbNuzT9qBBavbLwCsOGabYfZo0T0to5eqruptLy" crossorigin="anonymous"></script> 
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    
    <style>
        body,#renderCanvas { width: 100%; height: 100vh !important;}
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
   <!-- Modal -->
    <div class="modal fade" id="saveDialog">
        <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
            <h1 class="modal-title fs-5" id="exampleModalLabel">Enregistrez ...</h1>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <label for="origamiName" class="col-form-label">Entrez le nom de votre Origami:</label>
                <input type="text" class="form-control" id="origamiName">
            </div>
            <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Annuler</button>
            <button type="button" class="btn btn-primary" id="saveButton">Enregistrer les changements</button>
            </div>
        </div>
        </div>
    </div>
    <div class="modal fade" id="openDialog">
        <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
            <h1 class="modal-title fs-5" id="exampleModalLabel">Enregistrez ...</h1>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <label for="origamiName" class="col-form-label">Choisissez l'origami a ouvrir:</label>
                <div class="list-group" id="openList" role="tablist">
                    <a class="list-group-item list-group-item-action active" id="list-home-list" data-bs-toggle="list" href="#list-home" role="tab" aria-controls="list-home">test1</a>
                    <a class="list-group-item list-group-item-action" id="list-profile-list" data-bs-toggle="list" href="#list-profile" role="tab" aria-controls="list-profile">test 1</a>
                    <a class="list-group-item list-group-item-action" id="list-messages-list" data-bs-toggle="list" href="#list-messages" role="tab" aria-controls="list-messages">test2</a>
                    <a class="list-group-item list-group-item-action" id="list-settings-list" data-bs-toggle="list" href="#list-settings" role="tab" aria-controls="list-settings">test 2</a>
                  </div>
            </div>
            <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Annuler</button>
            <button type="button" class="btn btn-primary" id="openButton">Ouvrir cet Origami</button>
            </div>
        </div>
        </div>
    </div>

    <script>
        //vect utilities
        function vsub(a,b)  { return [a[0]-b[0],a[1]-b[1],a[2]-b[2]];}
        function vadd(a,b)  { return [a[0]+b[0],a[1]+b[1],a[2]+b[2]];}
        function vdot(a,b)  { return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]}
        function vXprd(a,b) { return [a[1]*b[2]-a[2]*b[1],a[2]*b[0]-a[0]*b[2],a[0]*b[1]-b[0]*a[1]];}
        function smult(scal,a) { return [scal*a[0],scal*a[1],scal*a[2]];}
        function vnorm(v) { return Math.sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]);}
        function vnormalize(v) { return smult(1/vnorm(v),v); }

        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);
        const Palette = [[230, 25, 75], [60, 180, 75], [255, 225, 25], [0, 130, 200], [245, 130, 48], [145, 30, 180], [70, 240, 240], [240, 50, 230], [210, 245, 60], [250, 190, 212], [0, 128, 128], [220, 190, 255], [170, 110, 40], [255, 250, 200], [128, 0, 0], [170, 255, 195], [128, 128, 0], [255, 215, 180], [0, 0, 128], [128, 128, 128], [255, 255, 255], [0, 0, 0]].map((c)=>BABYLON.Color3.FromInts(c[0],c[1],c[2]));
        const SphD=0.2;
        var ui,theOrigami;
        const openModal = new bootstrap.Modal('#openDialog');       
        const  pattern = (active,name,i) => `<a class="list-group-item list-group-item-action ${active}" id="list-${i}-list" data-bs-toggle="list" href="#list-${i}" role="tab" aria-controls="list-${i}">${name}</a>`;
        const theList=document.getElementById("openList");

        document.getElementById('openButton').addEventListener("click",e => {
            let selected=theList.querySelector('.active').innerHTML;
            const toOpen=JSON.parse(localStorage[selected]);
            openModal.hide();
            theOrigami.name=selected;
            theOrigami.nameLbl.text=this.name;
            theOrigami.disposeAll();
            theOrigami=new Origami(scene,toOpen.pt,toOpen.f,selected);                   
        });

        const saveModal = new bootstrap.Modal('#saveDialog');
        const txt=document.getElementById("origamiName"); 
        document.getElementById('saveButton').addEventListener("click",e => {
            theOrigami.name=document.getElementById("origamiName").value;
            theOrigami.nameLbl.text=this.name;
            saveModal.hide();
            let saved=[];
            if(localStorage.hasOwnProperty("saved")) saved = JSON.parse(localStorage.saved);
            if(!saved.includes(theOrigami.name)) {saved.push(theOrigami.name); localStorage.saved=JSON.stringify(saved);}
            let value = { pt:theOrigami.points, f:theOrigami.faces};
            localStorage.setItem(theOrigami.name,JSON.stringify(value));
        });

        class Origami {            
            points=null;
            faces=null;
            name="";
            nameLbl;
            faceMeshes=[];
            VSelMeshes=null;
            ESelMeshes=[];
            selectedF=null;
            selectedE=-1;
            selectedV=-1;
            constructor(scene,pts,fa,na="") {
                this.points=pts;
                this.faces=fa;
                fa.forEach((f,idx)=>this.createFaceMesh(f,idx,scene));
                // GUI
                ui = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
                this.name=na;
                this.nameLbl = new BABYLON.GUI.TextBlock();
                this.nameLbl.text = this.name;
                this.nameLbl.color = "white";
                this.nameLbl.fontSize = 30;
                this.nameLbl.textVerticalAlignment=BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
                this.nameLbl.top=10
                ui.addControl(this.nameLbl);    

                let tlgrid=new BABYLON.GUI.Grid(); 
                tlgrid.horizontalAlignment=BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
                tlgrid.verticalAlignment=BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
                tlgrid.top=5;tlgrid.left=5;tlgrid.width=0.3;
                tlgrid.addColumnDefinition(0.15);tlgrid.addColumnDefinition(0.15);tlgrid.addColumnDefinition(0.15);
                tlgrid.addColumnDefinition(0.1);tlgrid.addColumnDefinition(0.15);
                tlgrid.addColumnDefinition(0.1);tlgrid.addColumnDefinition(0.2);
                tlgrid.addRowDefinition(40,true);tlgrid.addRowDefinition(40,true);
                ui.addControl(tlgrid);
                tlgrid.addControl(this.createButton("↑","w",0.04,"TL",10,"6%",() => {this.translateV([0,1],scene);}),0,1);
                tlgrid.addControl(this.createButton("↓","s",0.04,"TL",60,"6%",() => {this.translateV([0,-1],scene);}),1,1);
                tlgrid.addControl(this.createButton("←","a",0.04,"TL",35,"1%",() => {this.translateV([-1,0],scene);}),1,0);
                tlgrid.addControl(this.createButton("→","d",0.04,"TL",35,"11%",() => {this.translateV([1,0],scene);}),1,2);
                tlgrid.addControl(this.createButton("↻","r",0.04,"TL",35,"18%",() => {this.rotateFace(5,scene);}),0,4);
                tlgrid.addControl(this.createButton("↺","t",0.04,"TL",35,"23%",() => {this.rotateFace(-5,scene);}),1,4);
                tlgrid.addControl(this.createButton("fermer","f",0.05,"TL",110,"1%",() => {this.closeFacefromV(scene);}),0,6);
                let nouv=this.createButton("nouveau","n",0.06,"TR",200,"1%",() => {this.newFace(scene);});
                nouv.horizontalAlignment=BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
                nouv.verticalAlignment=BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
                nouv.width=0.08;nouv.height="40px";
                ui.addControl(nouv);
                let panel = new BABYLON.GUI.Grid();
                panel.addRowDefinition(40,true);panel.addColumnDefinition(0.5); panel.addColumnDefinition(0.5); 
                panel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
                panel.verticalAlignment=BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
                panel.width=0.2; panel.height="40px";
                
                panel.addControl(this.createButton("enregistrer","e",0.07,"BR",10,"7%",() => {this.save();}),0,0);
                panel.addControl(this.createButton("ouvrir","o",0.05,"BR",10,"1%",() => {this.open(scene);}),0,1);
                ui.addControl(panel);  
                
                
                scene.onKeyboardObservable.add((kbInfo) => {
                    switch (kbInfo.type) {
                        case BABYLON.KeyboardEventTypes.KEYDOWN:
                                console.log(kbInfo.event.key);
                                switch(kbInfo.event.key) {
                                    case "a":
                                        this.translateV([1,0],scene);
                                        break;
                                    case "d":
                                        this.translateV([-1,0],scene);
                                        break;
                                    case "w":
                                        this.translateV([0,1],scene);
                                        break;
                                    case "s":
                                        this.translateV([0,-1],scene);
                                        break;
                                    case "r":
                                        this.rotateFace(5,scene);
                                        break;
                                    case "t":
                                        this.rotateFace(-5,scene);
                                        break;
                                    case "e":
                                        this.extendFace(scene);
                                        break;
                                    case "n":
                                        this.newFace(scene);
                                        break;
                                    case "f":
                                        this.closeFacefromV(scene);
                                        break;
                                    case "Backspace":
                                        this.deleteFace(scene);
                                        break;
                                    case "Escape":
                                        this.unselectFace(scene);
                                        break;
                                }
                        break;
                    }
                });
            }
            open(scene) {
                if(!localStorage.hasOwnProperty("saved")) {
                    alert("Aucun origami enregistré!");
                    return;
                }
                const allOrig=JSON.parse(localStorage.saved);
                let ih="";
                allOrig.forEach((or,i)=>{ih=ih+pattern(i==0?"active":"",or,i);});
                theList.innerHTML=ih;
                openModal.show();
            }
            disposeAll() {
                if(this.faceMeshes!= null) this.faceMeshes.forEach(f=>{f.dispose();})
                if(this.VSelMeshes!= null) this.VSelMeshes.forEach(sm=>{sm.dispose();})
                if(this.ESelMeshes!= null) this.ESelMeshes.forEach(sm=>{sm.dispose();})
            }

            save() {
                txt.value=this.name;
                saveModal.show();
            }

            createButton(name,short,width,alignment,hdist,vdist,action) {
                const b = BABYLON.GUI.Button.CreateSimpleButton(name, name+"("+short+")");
                b.cornerRadius = 10;
                b.color = "White";
                b.thickness = 1;
                b.background = "Grey";
                b.onPointerClickObservable.add(action);
                b.paddingLeft=5; b.paddingRight=5;
                b.paddingTop=5; b.paddingBottom=5;        
                return b; 
            }
            createFaceMesh(f,idx,scene) {
                
                const Triangle = { "name":"Triangular Prism", "category":["Prism"], 
                    "vertex":this.computeFaceVertex(f),
                    "face":[[0,1,2],[3,5,4],[0,2,5,3],[2,1,4,5],[1,0,3,4]]};
                //console.log(Triangle.vertex); 
                const Prism = BABYLON.MeshBuilder.CreatePolyhedron("h", {custom: Triangle}, scene);
                Prism.actionManager =new BABYLON.ActionManager(scene);
                let _t=this;
                Prism.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickTrigger, 
                    function (evt) { _t.selectFace(f,scene); }));

                const material = new BABYLON.StandardMaterial("material", scene);
                material.diffuseColor = Palette[idx%Palette.length];
                Prism.material = material;
                this.faceMeshes[idx]=Prism;
            }
            computeFaceVertex(f) {
                const e=0.02; //face thickness

                let p0=this.points[f[0]],p1=this.points[f[1]],p2=this.points[f[2]];
                let p02=vsub(p2,p0);
                let p01=vsub(p1,p0);                      
                let norm = smult(e,vnormalize(vXprd(p02,p01)));
            
                return [vsub(p0,norm), vsub(p1,norm), vsub(p2,norm),
                        vadd(p0,norm), vadd(p1,norm), vadd(p2,norm)]; 
            }
            translateV(dir,scene) {
                if(this.selectedV<0||this.selectedF==null) return;
                let f=this.selectedF,v=this.points[f[this.selectedV]];
                let from=this.points[f[(this.selectedV+2)%3]],to=this.points[f[(this.selectedV+1)%3]];
                let base=vsub(to,from),fromv=vsub(v,from);
                let h=vsub(v, vadd(from,smult(vdot(fromv,base)/vdot(base,base),base)) );
                //console.log(this.selectedV+"|"+f+" - "+v+" - "+base+ " ,from:"+from+" ,to:"+to);
                v[0]+=(dir[0]*base[0]+dir[1]*h[0])/10;
                v[1]+=(dir[0]*base[1]+dir[1]*h[1])/10;
                v[2]+=(dir[0]*base[2]+dir[1]*h[2])/10;
                this.updateVertex(v,f[this.selectedV],scene);
                this.VSelMeshes[this.selectedV].position=new BABYLON.Vector3(v[0], v[1], v[2]);
                this.reComputeESel(this.selectedF);
            }
            rotateFace(angle,scene) {
                if(this.selectedV<0||this.selectedF==null) return;
                let f=this.selectedF,v=this.points[f[this.selectedV]];
                let from=this.points[f[(this.selectedV+2)%3]],to=this.points[f[(this.selectedV+1)%3]];
                let base=BABYLON.Vector3.Zero().fromArray(vnormalize(vsub(to,from))),la=BABYLON.Vector3.Zero().fromArray(vsub(v,from));
                let rotQ=BABYLON.Matrix.RotationAxis(base,angle*Math.PI/180);
                la=BABYLON.Vector3.TransformCoordinates(la,rotQ);
                v[0]=la.x+from[0];
                v[1]=la.y+from[1];
                v[2]=la.z+from[2];
                
                this.updateVertex(v,f[this.selectedV],scene);
                this.VSelMeshes[this.selectedV].position=new BABYLON.Vector3(v[0], v[1], v[2]);
                this.reComputeESel(this.selectedF);
            }
            

            updateVertex(v,idx,scene) {
                let orig=this;
                this.faces.forEach((f,i)=>{
                    f.some( (pt,j)=>{
                        if(pt==idx) {
                            orig.faceMeshes[i].dispose();
                            this.createFaceMesh(f,i,scene);
                            return true;
                        }
                        return false;
                    });
                });
            }
            selectFace(f,scene) {
                if(this.VSelMeshes==null) {
                    this.VSelMeshes = [];
                    for(let k=0;k<10;++k) this.VSelMeshes.push(BABYLON.Mesh.CreateSphere("p"+k, 10, SphD, scene,true));
                
                    this.VSelMeshes.forEach((m,i)=>{
                        m.material = new BABYLON.StandardMaterial("material", scene);
                        m.actionManager =new BABYLON.ActionManager(scene);
                        let _t=this;
                        m.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickTrigger, 
                            function (evt) { _t.selectVertex(i,scene); }));
                    });
                }
                this.reComputeESel(f);
                for(let j=f.length;j<10;++j) {
                    this.VSelMeshes[j].isVisible = false;
                }
                this.selectedF=f;
                this.selectEdge(-1,scene);
                this.selectVertex(-1,scene);
                console.log("Selected "+f);
            }
            unselectFace(scene) {
                for(let j=0;j<10;++j) {
                    this.VSelMeshes[j].isVisible = false;
                }
                this.ESelMeshes.forEach(m=>m.dispose());
                this.ESelMeshes=[];
                this.selectedF=null;
                this.selectEdge(-1,scene);
                this.selectVertex(-1,scene); 
            }
            reComputeESel(f) {
                this.ESelMeshes.forEach(m=>m.dispose());
                this.ESelMeshes=[];
                for(let j=0;j<f.length;++j) {
                    let p= this.points[f[j]];
                    this.VSelMeshes[j].position = new BABYLON.Vector3(p[0], p[1], p[2]);
                    this.VSelMeshes[j].isVisible=true;                   
                    this.ESelMeshes.push(this.getEdgeCyl(f,j,scene));
                }
            }
            getEdgeCyl(f,edgeIdx,scene) {
                    let p1=new BABYLON.Vector3().fromArray(this.points[f[edgeIdx]]);
                    let p2=new BABYLON.Vector3().fromArray(this.points[f[(edgeIdx+1)%f.length]]);
                    let distance = BABYLON.Vector3.Distance(p1,p2 )-SphD;
                
                    let cylinder = BABYLON.MeshBuilder.CreateCylinder("cylinder", 
                        {height:distance, diameterTop:0.1, diameterBottom:0.1, tessellation:6, subdivisions:1}, scene);
                    cylinder.material = new BABYLON.StandardMaterial("material", scene);
                    cylinder.actionManager =new BABYLON.ActionManager(scene);
                    let _t=this;
                    cylinder.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickTrigger, 
                        function (evt) { _t.selectEdge(edgeIdx,scene); }));
                    let diff=p2.subtract(p1);
                    //position cylinder in between p1 and p2
                    cylinder.position = p1.add(diff.scale(0.5));              
                    // rotate as needed
                    let rot=BABYLON.Quaternion.Zero();
                    BABYLON.Quaternion.FromUnitVectorsToRef(new BABYLON.Vector3(0,1, 0), diff.normalize(),rot );
                    cylinder.rotationQuaternion=rot;
                    return cylinder;
            }
            selectVertex(i,scene) {
                this.VSelMeshes.forEach((m,idx)=> { m.material.diffuseColor=(i==idx?BABYLON.Color3.Yellow():BABYLON.Color3.White()); });
                this.selectedV=i;
                if(i>=0) console.log("Selected V"+this.selectedF[i]);
            }
            selectEdge(i,scene) {
                this.ESelMeshes.forEach((m,idx)=> { m.material.diffuseColor=(i==idx?BABYLON.Color3.Yellow():BABYLON.Color3.White()); });
                this.selectedE=i;
                
            }
            newFace(scene) {
                if(this.selectedE<0) return;
                let p1i=this.selectedF[this.selectedE], p2i=this.selectedF[(this.selectedE+1)%this.selectedF.length];
                let p1=new BABYLON.Vector3().fromArray(this.points[p1i]);
                let p2=new BABYLON.Vector3().fromArray(this.points[p2i]);
                if(this.findFacesContaining(p1i,p2i).length ==2) return; // edge already has 2 faces cannot add one
                let cam=scene.activeCamera.getForwardRay().direction;
                let base=p2.subtract(p1);
                let mid=p1.add(p2.subtract(p1).scale(0.5));
                //let lines = BABYLON.MeshBuilder.CreateLines("lines", { points:[mid,mid.add(cam)] }, scene);
                let newPt=mid.add(cam.applyRotationQuaternion(BABYLON.Quaternion.RotationAxis(base,120*Math.PI/180)).scale(0.707));
                //console.log(newPt);
                let newFace=[p1i,p2i,this.points.length];
                this.points.push([newPt.x,newPt.y,newPt.z]);
                this.faces.push(newFace);               
                this.createFaceMesh(newFace,this.faces.length-1,scene);
                this.selectFace(newFace,scene);
            }
            extendFace(scene) {
                if(this.selectedE<0) return;
                let p1i=this.selectedE, p2i=(this.selectedE+1)%f.length;
                let p1=new BABYLON.Vector3().fromArray(this.points[p1i]);
                let p2=new BABYLON.Vector3().fromArray(this.points[p2i]);

            }
            findFacesContaining(p1,p2) {
                let res=[];
                this.faces.forEach( (f,fidx)=>{
                    let hasp1=false,hasp2=false;
                    f.forEach(v=>{if(v==p1) hasp1=true; else if(v==p2) hasp2=true;});
                    if(hasp1 && hasp2) res.push(fidx);
                })
                return res;
            }
            closeFacefromV(scene) {
                if(this.selectedV <0) return;
                let curV=this.selectedF[this.selectedV];
                let fe=this.findFreeEdges(curV);
                if(fe.size != 2) return;
                let newFace=[curV];
                fe.forEach( v=> {newFace.push(v);});
                this.faces.push(newFace);               
                this.createFaceMesh(newFace,this.faces.length-1,scene);
                this.selectFace(newFace,scene);

            }
            findFreeEdges(v) {
                let s=new Set();
                this.faces.forEach( (f)=>{
                    f.some((vert,vIdx)=>{
                        if(vert==v) {
                            let prev=f[vIdx==0?f.length-1:vIdx-1];
                            let next=f[vIdx==f.length-1?0:vIdx+1];
                            if(s.has(prev)) { s.delete(prev);} else {s.add(prev);}
                            if(s.has(next)) { s.delete(next);} else {s.add(next);}
                            return true;
                        }
                        return false;
                    });
                });
                return s;
            }
            deleteFace(scene) {

                if(this.selectedF==null) return;
                let toBeDeleted=[];
                this.selectedF.filter(v=>{
                    let found=false;
                    top:
                    for(const f of this.faces) {
                        if(f != this.selectedF) {
                            for(const ov of f) { 
                                if(ov==v) {
                                    found=true
                                    break top;
                                }
                            }
                        }
                    }
                    if(!found) toBeDeleted.push(v);
                });
                let sel=this.faces.indexOf(this.selectedF);
                this.unselectFace(scene);               
                this.faces.splice(sel,1);
                this.faceMeshes[sel].dispose();
                this.faceMeshes.splice(sel,1);
                for(const v of toBeDeleted) this.delPt(v);
            }
            delPt(vIdx) {
                this.points.splice(vIdx,1);
                for(const f of this.faces) {
                    for(let i=0;i<f.length;++i) if(f[i]>vIdx) --f[i];
                }
            }
        }
        
        

        const createScene = function() {
            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3.Black;

            const alpha =  Math.PI/4;
            const beta = Math.PI/3;
            const radius = 8;
            const target = new BABYLON.Vector3(0, 0, 0);
            const camera = new BABYLON.ArcRotateCamera("Camera", alpha, beta, radius, target, scene);
            camera.inputs.attached.mousewheel.wheelPrecision=40;
            camera.attachControl(canvas, true);

            const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(1, 1, 0));

            const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 4, height: 4});
            theOrigami= new Origami(scene,[[0,0,0.5],[1,0,0.5],[0,1,0.5],[0,0,1.5]],[[0,1,2],[0,3,1],[0,2,3]]);
            return scene;

        };

        scene=createScene();
        engine.runRenderLoop(() => scene.render());
    </script>
</body>
</html>
