<html>
<head>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://unpkg.com/mathjs@12.4.1/lib/browser/math.js" type="text/javascript"></script>
    <style>
        body,#renderCanvas { width: 100%; height: 100%;}
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    <script>
        //vect utilities
        function vsub(a,b)  { return [a[0]-b[0],a[1]-b[1],a[2]-b[2]];}
        function vadd(a,b)  { return [a[0]+b[0],a[1]+b[1],a[2]+b[2]];}
        function vdot(a,b)  { return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]}
        function vXprd(a,b) { return [a[1]*b[2]-a[2]*b[1],a[2]*b[0]-a[0]*b[2],a[0]*b[1]-b[0]*a[1]];}
        function smult(scal,a) { return [scal*a[0],scal*a[1],scal*a[2]];}
        function vnorm(v) { return Math.sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]);}
        function vnormalize(v) { return smult(1/vnorm(v),v); }

        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);
        const Palette = [[230, 25, 75], [60, 180, 75], [255, 225, 25], [0, 130, 200], [245, 130, 48], [145, 30, 180], [70, 240, 240], [240, 50, 230], [210, 245, 60], [250, 190, 212], [0, 128, 128], [220, 190, 255], [170, 110, 40], [255, 250, 200], [128, 0, 0], [170, 255, 195], [128, 128, 0], [255, 215, 180], [0, 0, 128], [128, 128, 128], [255, 255, 255], [0, 0, 0]].map((c)=>BABYLON.Color3.FromInts(c[0],c[1],c[2]));
        const SphD=0.2;

        class Origami {
            points=null;
            faces=null;
            faceMeshes=[];
            VSelMeshes=null;
            ESelMeshes=[];
            selectedF=null;
            selectedE=-1;
            selectedV=-1;
            constructor(scene,pts,fa) {
                this.points=pts;
                this.faces=fa;
                fa.forEach((f,idx)=>this.createFaceMesh(f,idx,scene));
                scene.onKeyboardObservable.add((kbInfo) => {
                    switch (kbInfo.type) {
                        case BABYLON.KeyboardEventTypes.KEYUP:
                                console.log(kbInfo.event.key);
                                switch(kbInfo.event.key) {
                                    case "a":
                                        this.translateV([1,0],scene);
                                        break;
                                    case "d":
                                        this.translateV([-1,0],scene);
                                        break;
                                    case "w":
                                        this.translateV([0,1],scene);
                                        break;
                                    case "s":
                                        this.translateV([0,-1],scene);
                                        break;
                                    case "r":
                                        this.rotateFace(5,scene);
                                        break;
                                    case "t":
                                        this.rotateFace(-5,scene);
                                        break;
                                    case "e":
                                        this.extendFace(scene);
                                        break;
                                    case "n":
                                        this.newFace(scene);
                                        break;
                                    case "c":
                                        this.closeFacefromV(scene);
                                        break;
                                    case "Delete":
                                        this.deleteFace(scene);
                                        break;
                                    case "Escape":
                                        this.unselectFace(scene);
                                        break;
                                }
                        break;
                    }
                });
            }
            createFaceMesh(f,idx,scene) {
                
                const Triangle = { "name":"Triangular Prism", "category":["Prism"], 
                    "vertex":this.computeFaceVertex(f),
                    "face":[[0,1,2],[3,5,4],[0,2,5,3],[2,1,4,5],[1,0,3,4]]};
                //console.log(Triangle.vertex); 
                const Prism = BABYLON.MeshBuilder.CreatePolyhedron("h", {custom: Triangle}, scene);
                Prism.actionManager =new BABYLON.ActionManager(scene);
                let _t=this;
                Prism.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickTrigger, 
                    function (evt) { _t.selectFace(f,scene); }));

                const material = new BABYLON.StandardMaterial("material", scene);
                material.diffuseColor = Palette[idx%Palette.length];
                Prism.material = material;
                this.faceMeshes[idx]=Prism;
            }
            computeFaceVertex(f) {
                const e=0.02; //face thickness

                let p0=this.points[f[0]],p1=this.points[f[1]],p2=this.points[f[2]];
                let p02=vsub(p2,p0);
                let p01=vsub(p1,p0);                      
                let norm = smult(e,vnormalize(vXprd(p02,p01)));
            
                return [vsub(p0,norm), vsub(p1,norm), vsub(p2,norm),
                        vadd(p0,norm), vadd(p1,norm), vadd(p2,norm)]; 
            }
            translateV(dir,scene) {
                if(this.selectedV<0||this.selectedF==null) return;
                let f=this.selectedF,v=this.points[f[this.selectedV]];
                let from=this.points[f[(this.selectedV+2)%3]],to=this.points[f[(this.selectedV+1)%3]];
                let base=vsub(to,from),fromv=vsub(v,from);
                let h=vsub(v, vadd(from,smult(vdot(fromv,base)/vdot(base,base),base)) );
                //console.log(this.selectedV+"|"+f+" - "+v+" - "+base+ " ,from:"+from+" ,to:"+to);
                v[0]+=(dir[0]*base[0]+dir[1]*h[0])/10;
                v[1]+=(dir[0]*base[1]+dir[1]*h[1])/10;
                v[2]+=(dir[0]*base[2]+dir[1]*h[2])/10;
                this.updateVertex(v,f[this.selectedV],scene);
                this.VSelMeshes[this.selectedV].position=new BABYLON.Vector3(v[0], v[1], v[2]);
                this.reComputeESel(this.selectedF);
            }
            rotateFace(angle,scene) {
                if(this.selectedV<0||this.selectedF==null) return;
                let f=this.selectedF,v=this.points[f[this.selectedV]];
                let from=this.points[f[(this.selectedV+2)%3]],to=this.points[f[(this.selectedV+1)%3]];
                let base=vnormalize(vsub(to,from)),la=vsub(v,from);
                let k=[[0,-base[2],base[1]],[base[2],0,-base[0]],[-base[1],base[0],0]],k2=math.multiply(k,k),i=[[1,0,0],[0,1,0],[0,0,1]];
                let ra=angle*Math.PI/180;
                let rot=math.add(i,math.multiply(math.sin(ra),k),math.multiply(1-math.cos(ra)*math.cos(ra),k2));
                let nv=math.multiply(rot,la);
                v[0]=nv[0]+from[0];
                v[1]=nv[1]+from[1];
                v[2]=nv[2]+from[2];
                this.updateVertex(v,f[this.selectedV],scene);
                this.VSelMeshes[this.selectedV].position=new BABYLON.Vector3(v[0], v[1], v[2]);
                this.reComputeESel(this.selectedF);
            }
            

            updateVertex(v,idx,scene) {
                let orig=this;
                this.faces.forEach((f,i)=>{
                    f.some( (pt,j)=>{
                        if(pt==idx) {
                            orig.faceMeshes[i].dispose();
                            this.createFaceMesh(f,i,scene);
                            return true;
                        }
                        return false;
                    });
                });
            }
            selectFace(f,scene) {
                if(this.VSelMeshes==null) {
                    this.VSelMeshes = [];
                    for(let k=0;k<10;++k) this.VSelMeshes.push(BABYLON.Mesh.CreateSphere("p"+k, 10, SphD, scene,true));
                
                    this.VSelMeshes.forEach((m,i)=>{
                        m.material = new BABYLON.StandardMaterial("material", scene);
                        m.actionManager =new BABYLON.ActionManager(scene);
                        let _t=this;
                        m.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickTrigger, 
                            function (evt) { _t.selectVertex(i,scene); }));
                    });
                }
                this.reComputeESel(f);
                for(let j=f.length;j<10;++j) {
                    this.VSelMeshes[j].isVisible = false;
                }
                this.selectedF=f;
                this.selectEdge(-1,scene);
                this.selectVertex(-1,scene);
                console.log("Selected "+f);
            }
            unselectFace(scene) {
                for(let j=0;j<10;++j) {
                    this.VSelMeshes[j].isVisible = false;
                }
                this.ESelMeshes.forEach(m=>m.dispose());
                this.ESelMeshes=[];
                this.selectedF=null;
                this.selectEdge(-1,scene);
                this.selectVertex(-1,scene); 
            }
            reComputeESel(f) {
                this.ESelMeshes.forEach(m=>m.dispose());
                this.ESelMeshes=[];
                for(let j=0;j<f.length;++j) {
                    let p= this.points[f[j]];
                    this.VSelMeshes[j].position = new BABYLON.Vector3(p[0], p[1], p[2]);
                    this.VSelMeshes[j].isVisible=true;                   
                    this.ESelMeshes.push(this.getEdgeCyl(f,j,scene));
                }
            }
            getEdgeCyl(f,edgeIdx,scene) {
                    let p1=new BABYLON.Vector3().fromArray(this.points[f[edgeIdx]]);
                    let p2=new BABYLON.Vector3().fromArray(this.points[f[(edgeIdx+1)%f.length]]);
                    let distance = BABYLON.Vector3.Distance(p1,p2 )-SphD;
                
                    let cylinder = BABYLON.MeshBuilder.CreateCylinder("cylinder", 
                        {height:distance, diameterTop:0.1, diameterBottom:0.1, tessellation:6, subdivisions:1}, scene);
                    cylinder.material = new BABYLON.StandardMaterial("material", scene);
                    cylinder.actionManager =new BABYLON.ActionManager(scene);
                    let _t=this;
                    cylinder.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickTrigger, 
                        function (evt) { _t.selectEdge(edgeIdx,scene); }));
                    let diff=p2.subtract(p1);
                    //position cylinder in between p1 and p2
                    cylinder.position = p1.add(diff.scale(0.5));              
                    // rotate as needed
                    let rot=BABYLON.Quaternion.Zero();
                    BABYLON.Quaternion.FromUnitVectorsToRef(new BABYLON.Vector3(0,1, 0), diff.normalize(),rot );
                    cylinder.rotationQuaternion=rot;
                    return cylinder;
            }
            selectVertex(i,scene) {
                this.VSelMeshes.forEach((m,idx)=> { m.material.diffuseColor=(i==idx?BABYLON.Color3.Yellow():BABYLON.Color3.White()); });
                this.selectedV=i;
                if(i>=0) console.log("Selected V"+this.selectedF[i]);
            }
            selectEdge(i,scene) {
                this.ESelMeshes.forEach((m,idx)=> { m.material.diffuseColor=(i==idx?BABYLON.Color3.Yellow():BABYLON.Color3.White()); });
                this.selectedE=i;
                
            }
            newFace(scene) {
                if(this.selectedE<0) return;
                let p1i=this.selectedF[this.selectedE], p2i=this.selectedF[(this.selectedE+1)%this.selectedF.length];
                let p1=new BABYLON.Vector3().fromArray(this.points[p1i]);
                let p2=new BABYLON.Vector3().fromArray(this.points[p2i]);
                if(this.findFacesContaining(p1i,p2i).length ==2) return; // edge already has 2 faces cannot add one
                let cam=scene.activeCamera.getForwardRay().direction;
                let base=p2.subtract(p1);
                let mid=p1.add(p2.subtract(p1).scale(0.5));
                //let lines = BABYLON.MeshBuilder.CreateLines("lines", { points:[mid,mid.add(cam)] }, scene);
                let newPt=mid.add(cam.applyRotationQuaternion(BABYLON.Quaternion.RotationAxis(base,120*Math.PI/180)).scale(0.707));
                //console.log(newPt);
                let newFace=[p1i,p2i,this.points.length];
                this.points.push([newPt.x,newPt.y,newPt.z]);
                this.faces.push(newFace);               
                this.createFaceMesh(newFace,this.faces.length-1,scene);
                this.selectFace(newFace,scene);
            }
            extendFace(scene) {
                if(this.selectedE<0) return;
                let p1i=this.selectedE, p2i=(this.selectedE+1)%f.length;
                let p1=new BABYLON.Vector3().fromArray(this.points[p1i]);
                let p2=new BABYLON.Vector3().fromArray(this.points[p2i]);

            }
            findFacesContaining(p1,p2) {
                let res=[];
                this.faces.forEach( (f,fidx)=>{
                    let hasp1=false,hasp2=false;
                    f.forEach(v=>{if(v==p1) hasp1=true; else if(v==p2) hasp2=true;});
                    if(hasp1 && hasp2) res.push(fidx);
                })
                return res;
            }
            closeFacefromV(scene) {
                if(this.selectedV <0) return;
                let curV=this.selectedF[this.selectedV];
                let fe=this.findFreeEdges(curV);
                if(fe.size != 2) return;
                let newFace=[curV];
                fe.forEach( v=> {newFace.push(v);});
                this.faces.push(newFace);               
                this.createFaceMesh(newFace,this.faces.length-1,scene);
                this.selectFace(newFace,scene);

            }
            findFreeEdges(v) {
                let s=new Set();
                this.faces.forEach( (f)=>{
                    f.some((vert,vIdx)=>{
                        if(vert==v) {
                            let prev=f[vIdx==0?f.length-1:vIdx-1];
                            let next=f[vIdx==f.length-1?0:vIdx+1];
                            if(s.has(prev)) { s.delete(prev);} else {s.add(prev);}
                            if(s.has(next)) { s.delete(next);} else {s.add(next);}
                            return true;
                        }
                        return false;
                    });
                });
                return s;
            }
            deleteFace(scene) {

                if(this.selectedF==null) return;
                let toBeDeleted=[];
                this.selectedF.filter(v=>{
                    let found=false;
                    top:
                    for(const f of this.faces) {
                        if(f != this.selectedF) {
                            for(const ov of f) { 
                                if(ov==v) {
                                    found=true
                                    break top;
                                }
                            }
                        }
                    }
                    if(!found) toBeDeleted.push(v);
                });
                let sel=this.faces.indexOf(this.selectedF);
                this.unselectFace(scene);               
                this.faces.splice(sel,1);
                this.faceMeshes[sel].dispose();
                this.faceMeshes.splice(sel,1);
                for(const v of toBeDeleted) this.delPt(v);
            }
            delPt(vIdx) {
                this.points.splice(vIdx,1);
                for(const f of this.faces) {
                    for(let i=0;i<f.length;++i) if(f[i]>vIdx) --f[i];
                }
            }
        }
        
        

        const createScene = function() {
            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3.Black;

            const alpha =  Math.PI/4;
            const beta = Math.PI/3;
            const radius = 8;
            const target = new BABYLON.Vector3(0, 0, 0);
            const camera = new BABYLON.ArcRotateCamera("Camera", alpha, beta, radius, target, scene);
            camera.attachControl(canvas, true);

            const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(1, 1, 0));

            const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 4, height: 4});
            o= new Origami(scene,[[0,0,0.5],[1,0,0.5],[0,1,0.5],[0,0,1.5]],[[0,1,2],[0,3,1],[0,2,3] /*,[1,3,2]*/]);
            return scene;

        };

        scene=createScene();
        engine.runRenderLoop(() => scene.render());
    </script>
</body>
</html>
