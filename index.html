<html>
<head>
    <link rel="icon" type="image/x-icon" href="favicon.PNG">
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.js" type="text/javascript"></script>

    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.8/dist/umd/popper.min.js" integrity="sha384-I7E8VVD/ismYTF4hNIPjVp/Zjvgyol6VFvRkX/vR+Vc4jQkC+hVqc2pM8ODewa9r" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.min.js" integrity="sha384-0pUGZvbkm6XF6gxjEnlmuGrJXVbNuzT9qBBavbLwCsOGabYfZo0T0to5eqruptLy" crossorigin="anonymous"></script> 
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    
    <style>
        body,#renderCanvas { width: 100%; height: 100%;}
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
   <!-- Modal -->
    <div class="modal fade" id="saveDialog">
        <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
            <h1 class="modal-title fs-5" id="exampleModalLabel">Enregistrez cet origami</h1>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <label for="origamiName" class="col-form-label">Entrez le nom de votre origami:</label>
                <input type="text" class="form-control" id="origamiName">
            </div>
            <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Annuler</button>
            <button type="button" class="btn btn-primary" id="saveButton">Enregistrer les changements</button>
            </div>
        </div>
        </div>
    </div>
    <div class="modal fade" id="openDialog">
        <div class="modal-dialog modal-dialog-scrollable">
        <div class="modal-content">
            <div class="modal-header">
            <h1 class="modal-title fs-5" id="exampleModalLabel">Ouvrir un Origami enregistr√©</h1>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <label for="origamiName" class="col-form-label">Choisissez l'origami a ouvrir:</label>
                <div class="list-group" id="openList" role="tablist"></div>
            </div>
            <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Annuler</button>
            <button type="button" class="btn btn-primary" id="openButton">Ouvrir cet Origami</button>
            </div>
        </div>
        </div>
    </div>

    <div class="modal fade" id="importDialog">
        <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
            <h1 class="modal-title fs-5" id="exampleModalLabel">Importer un origami re√ßu par mail</h1>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <label for="importData" class="col-form-label">Entrez le contenu du mail:</label>
                <input type="text" class="form-control" id="importData" oninput="try{importName.value=JSON.parse(importData.value).name;} catch(e){}">
                <label for="importName" class="col-form-label">Entrez le nom a enregistrer:</label>
                <input type="text" class="form-control" id="importName" >
            </div>
            <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Annuler</button>
            <button type="button" class="btn btn-primary" id="importButton">Importer</button>
            </div>
        </div>
        </div>
    </div>

    <script>
        
        //vect utilities
        function vsub(a,b)  { return [a[0]-b[0],a[1]-b[1],a[2]-b[2]];}
        function vadd(a,b)  { return [a[0]+b[0],a[1]+b[1],a[2]+b[2]];}
        function vdot(a,b)  { return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]}
        function vXprd(a,b) { return [a[1]*b[2]-a[2]*b[1],a[2]*b[0]-a[0]*b[2],a[0]*b[1]-b[0]*a[1]];}
        function smult(scal,a) { return [scal*a[0],scal*a[1],scal*a[2]];}
        function vnorm(v) { return Math.sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]);}
        function vnormalize(v) { return smult(1/vnorm(v),v); }

        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);
        const Palette = [[230, 25, 75], [60, 180, 75], [255, 225, 25], [0, 130, 200], [245, 130, 48], [145, 30, 180], [70, 240, 240], [240, 50, 230], [210, 245, 60], [250, 190, 212], [0, 128, 128], [220, 190, 255], [170, 110, 40], [255, 250, 200], [128, 0, 0], [170, 255, 195], [128, 128, 0], [255, 215, 180], [0, 0, 128], [128, 128, 128], [255, 255, 255], [0, 0, 0]].map((c)=>BABYLON.Color3.FromInts(c[0],c[1],c[2]));
        const SphD=0.2;
        var ui,theOrigami,nameLbl;
        
        const openModal = new bootstrap.Modal('#openDialog');       
        const  pattern = (active,name,i) => `<a class="list-group-item list-group-item-action ${active}" id="list-${i}-list" data-bs-toggle="list" href="#list-${i}" role="tab" aria-controls="list-${i}">${name}</a>`;
        const theList=document.getElementById("openList");

        document.getElementById('openButton').addEventListener("click",e => {
            let selected=theList.querySelector('.active').innerHTML;
            const toOpen=JSON.parse(localStorage[selected]);
            openModal.hide();
            theOrigami.disposeAll();
            theOrigami=new Origami(scene,toOpen.pt,toOpen.f,selected);                   
        });

        const saveModal = new bootstrap.Modal('#saveDialog');
        const txt=document.getElementById("origamiName"); 
        document.getElementById('saveButton').addEventListener("click",e => {
            theOrigami.name=document.getElementById("origamiName").value;
            nameLbl.text=theOrigami.name;
            saveModal.hide();
            let saved=[];
            if(localStorage.hasOwnProperty("saved")) saved = JSON.parse(localStorage.saved);
            if(!saved.includes(theOrigami.name)) {saved.push(theOrigami.name); localStorage.saved=JSON.stringify(saved);}
            let value = { pt:theOrigami.points, f:theOrigami.faces};
            localStorage.setItem(theOrigami.name,JSON.stringify(value));
        });

        const importModal=new bootstrap.Modal('#importDialog');
        const impName = document.getElementById("importName");
        const impDat = document.getElementById("importData");
        document.getElementById('importButton').addEventListener("click",e => {
            if(impName.value==null || impName.value=="") { alert("Entrez un nom avant import"); return;}
            let toImport=null;
            try { toImport=JSON.parse(impDat.value);}
            catch(e) {
                alert("Donn√©es invalides!"); return; 
            }
            importModal.hide();
            let saved=[];
            if(localStorage.hasOwnProperty("saved")) saved = JSON.parse(localStorage.saved);
            if(!saved.includes(impName.value)) {saved.push(impName.value); localStorage.saved=JSON.stringify(saved);} 
            let value = { pt:toImport.pt, f:toImport.f};
            localStorage.setItem(impName.value,JSON.stringify(value));
        });

        
        class Ui {
            ui;
            lang="fr";
            keyCB={};
            Controls={};
            
            cb= {
                "up"        : ()=>theOrigami.translateV([0,1],scene),
                "down"      : ()=>theOrigami.translateV([0,-1],scene),
                "left"      : ()=>theOrigami.translateV([-1,0],scene),
                "right"     : ()=>theOrigami.translateV([1,0],scene),
                "rot+"      : ()=>theOrigami.rotateFace(5,scene),
                "rot-"      : ()=>theOrigami.rotateFace(-5,scene),
                "extend"    : ()=>theOrigami.extendFace(scene),                 
                "new"       : ()=>theOrigami.newFace(scene),
                "close"     : ()=>theOrigami.closeFacefromV(scene),
                "del"       : ()=>theOrigami.deleteFace(scene),
                "esc"       : ()=>theOrigami.unselectFace(scene),
                "save"      : ()=>theOrigami.save(),
                "open"      : ()=>theOrigami.open(scene),
                "mail"  	: ()=>theOrigami.email(),
                "import"    : ()=>theOrigami.import() 
            }
            i18n = {
                "fr": {
                    "up"        : ["‚Üë","z"], 
                    "down"      : ["‚Üì","s"],
                    "left"      : ["‚Üê","q"],
                    "right"     : ["‚Üí","d"],
                    "rot+"      : ["‚Üª","r"],
                    "rot-"      : ["‚Ü∫","t"],
                    "extend"    : ["","x"],                 
                    "new"       : ["nouveau","n"],
                    "close"     : ["fermer","f"],
                    "del"       : ["effacer",""],
                    "esc"       : ["unselect","Escape"],
                    "save"      : ["enregisrer","e"],
                    "open"      : ["ouvrir","o"],
                    "mail"  	: ["üìß","m"],
                    "import"    : ["importer","i"]
                },
                "en": {
                    "up"        : ["‚Üë","w"],
                    "down"      : ["‚Üì","s"],
                    "left"      : ["‚Üê","a"],
                    "right"     : ["‚Üí","d"],
                    "rot+"      : ["‚Üª","r"],
                    "rot-"      : ["‚Ü∫","t"],
                    "extend"    : ["","x"],                 
                    "new"       : ["new","n"],
                    "close"     : ["close","c"],
                    "del"       : ["delete","Delete"],
                    "esc"       : ["unselect","Escape"],
                    "save"      : ["save","v"],
                    "open"      : ["open","o"],
                    "mail"  	: ["üìß","m"],
                    "import"    : ["import","i"]
                }
            }
            setLang(l) {
                this.lang=l;
                this.keyCB={};
                for(const k of Object.getOwnPropertyNames(this.i18n[this.lang])) { 
                    this.keyCB[this.i18n[this.lang][k][1]]=this.cb[k];
                    if(this.Controls[k] != null) this.Controls[k].textBlock.text=this.i18n[this.lang][k][0]+"("+this.i18n[this.lang][k][1]+")";
                }
            }
            createButton(name) {
                const b = BABYLON.GUI.Button.CreateSimpleButton(name, this.i18n[this.lang][name][0]+"("+this.i18n[this.lang][name][1]+")");
                b.cornerRadius = 10;
                b.color = "White";
                b.thickness = 1;
                b.background = "Grey";
                b.onPointerClickObservable.add(this.cb[name]);
                b.paddingLeft=5; b.paddingRight=5;
                b.paddingTop=5; b.paddingBottom=5;
                this.Controls[name]=b;       
                return b; 
            }
            constructor(scene) {
                // GUI
                ui = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
                nameLbl = new BABYLON.GUI.TextBlock();
                nameLbl.text = "";
                nameLbl.color = "white";
                nameLbl.fontSize = 30;
                nameLbl.textVerticalAlignment=BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
                nameLbl.top=10
                ui.addControl(nameLbl);    

                let tlgrid=new BABYLON.GUI.Grid(); 
                tlgrid.horizontalAlignment=BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
                tlgrid.verticalAlignment=BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
                tlgrid.top=5;tlgrid.left=5;tlgrid.width=0.4;
                tlgrid.addColumnDefinition(60,true);tlgrid.addColumnDefinition(60,true);tlgrid.addColumnDefinition(60,true);
                tlgrid.addColumnDefinition(40,true);tlgrid.addColumnDefinition(60,true);
                tlgrid.addColumnDefinition(40,true);tlgrid.addColumnDefinition(100,true);
                tlgrid.addRowDefinition(40,true);tlgrid.addRowDefinition(40,true);
                ui.addControl(tlgrid);
                tlgrid.addControl(this.createButton("up"),0,1);
                tlgrid.addControl(this.createButton("down"),1,1);
                tlgrid.addControl(this.createButton("left"),1,0);
                tlgrid.addControl(this.createButton("right"),1,2);
                tlgrid.addControl(this.createButton("rot-"),0,4);
                tlgrid.addControl(this.createButton("rot+"),1,4);
                tlgrid.addControl(this.createButton("close"),0,6);
                let nouv=this.createButton("new");
                nouv.horizontalAlignment=BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
                nouv.verticalAlignment=BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
                nouv.width="120px";nouv.height="40px";
                ui.addControl(nouv);
                let panel = new BABYLON.GUI.Grid();
                panel.addRowDefinition(40,true);
                panel.addColumnDefinition(0.35); panel.addColumnDefinition(0.22); panel.addColumnDefinition(0.18);panel.addColumnDefinition(0.25);
                panel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
                panel.verticalAlignment=BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
                panel.width="400px"; panel.height="40px";
                
                panel.addControl(this.createButton("save"),0,0);
                panel.addControl(this.createButton("open"),0,1);
                panel.addControl(this.createButton("mail"),0,2);
                panel.addControl(this.createButton("import"),0,3);
                ui.addControl(panel);  
                
                //language selection
                let langPanel = new BABYLON.GUI.StackPanel();
                langPanel.addControl(this.addRadio("fr", langPanel,true));
                langPanel.addControl(this.addRadio("en", langPanel));

                let rect = new BABYLON.GUI.Rectangle();
                rect.width = "100px";
                rect.height = "70px";
                rect.left=5;
                rect.thickness=0;
                rect.horizontalAlignment=BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
                rect.verticalAlignment=BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
                rect.addControl(langPanel);
                ui.addControl(rect);
                // Activate the clipboard events listener
                ui.registerClipboardEvents();

                // Add event listener to onClipboardObservable
                ui.onClipboardObservable.add((ev) => {                   
                    if(ev.type === BABYLON.ClipboardEventTypes.COPY){
                        console.log(ev);
                        ev.event.clipboardData.setData("text/plain", "pt = "+JSON.stringify(theOrigami.points)+";\nf = "+JSON.stringify(theOrigami.faces)+";\n");

                    }
                });
                

                scene.onKeyboardObservable.add((kbInfo) => {
                    console.log(this.keyCB)
                    //console.log(kbInfo.event.key);
                    if( kbInfo.type == BABYLON.KeyboardEventTypes.KEYDOWN 
                            && this.keyCB[kbInfo.event.key]) 
                        this.keyCB[kbInfo.event.key]();
                });
                this.setLang(this.lang);
            }
            addRadio(text, parent,check=false) {
                const button = new BABYLON.GUI.RadioButton();
                button.width = "20px";
                button.height = "20px";
                button.color = "white";
                button.background = "green";     
                button.isChecked=check;
                const _ui=this;
                button.onIsCheckedChangedObservable.add(function(state) {
                    if (state) {
                        _ui.setLang(text);
                    }
                }); 
                const header = BABYLON.GUI.Control.AddHeader(button, text, "80px", { isHorizontal: true, controlFirst: true });
                header.height = "30px";
                header.color="White";
                return header;   
            }

        }

        class Origami {            
            points=null;
            faces=null;
            name="";
            faceMeshes=[];
            VSelMeshes=null;
            ESelMeshes=[];
            selectedF=null;
            selectedE=-1;
            selectedV=-1;
            constructor(scene,pts,fa,na="") {
                this.name=na;
                this.points=pts;
                this.faces=fa;
                fa.forEach((f,idx)=>this.createFaceMesh(f,idx,scene));
            }   
            email() {
                const toSend=JSON.stringify({name:this.name, pt:this.points, f:this.faces});
                window.location.href = "mailto:?subject=Origami: " + this.name+"&body="+toSend;
            }
            import() { importModal.show(); }

            open(scene) {
                if(!localStorage.hasOwnProperty("saved")) {
                    alert("Aucun origami enregistr√©!");
                    return;
                }
                const allOrig=JSON.parse(localStorage.saved);
                let ih="";
                allOrig.forEach((or,i)=>{ih=ih+pattern(i==0?"active":"",or,i);});
                theList.innerHTML=ih;
                openModal.show();
            }
            disposeAll() {
                if(this.faceMeshes!= null) this.faceMeshes.forEach(f=>{f.dispose();})
                if(this.VSelMeshes!= null) this.VSelMeshes.forEach(sm=>{sm.dispose();})
                if(this.ESelMeshes!= null) this.ESelMeshes.forEach(sm=>{sm.dispose();})
            }

            save() {
                txt.value=this.name;
                saveModal.show();
            }

            createFaceMesh(f,idx,scene) {
                
                const Triangle = { "name":"Triangular Prism", "category":["Prism"], 
                    "vertex":this.computeFaceVertex(f),
                    "face":[[0,1,2],[3,5,4],[0,2,5,3],[2,1,4,5],[1,0,3,4]]};
                //console.log(Triangle.vertex); 
                const Prism = BABYLON.MeshBuilder.CreatePolyhedron("h", {custom: Triangle}, scene);
                Prism.actionManager =new BABYLON.ActionManager(scene);
                let _t=this;
                Prism.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickTrigger, 
                    function (evt) { _t.selectFace(f,scene); }));

                const material = new BABYLON.StandardMaterial("material", scene);
                material.diffuseColor = Palette[idx%Palette.length];
                Prism.material = material;
                this.faceMeshes[idx]=Prism;
            }
            computeFaceVertex(f) {
                const e=0.02; //face thickness

                let p0=this.points[f[0]],p1=this.points[f[1]],p2=this.points[f[2]];
                let p02=vsub(p2,p0);
                let p01=vsub(p1,p0);                      
                let norm = smult(e,vnormalize(vXprd(p02,p01)));
            
                return [vsub(p0,norm), vsub(p1,norm), vsub(p2,norm),
                        vadd(p0,norm), vadd(p1,norm), vadd(p2,norm)]; 
            }
            translateV(dir,scene) {
                if(this.selectedV<0||this.selectedF==null) return;
                let f=this.selectedF,v=this.points[f[this.selectedV]];
                let from=this.points[f[(this.selectedV+2)%3]],to=this.points[f[(this.selectedV+1)%3]];
                let base=vsub(to,from),fromv=vsub(v,from);
                let h=vsub(v, vadd(from,smult(vdot(fromv,base)/vdot(base,base),base)) );
                //console.log(this.selectedV+"|"+f+" - "+v+" - "+base+ " ,from:"+from+" ,to:"+to);
                v[0]+=(dir[0]*base[0]+dir[1]*h[0])/10;
                v[1]+=(dir[0]*base[1]+dir[1]*h[1])/10;
                v[2]+=(dir[0]*base[2]+dir[1]*h[2])/10;
                this.updateVertex(v,f[this.selectedV],scene);
                this.VSelMeshes[this.selectedV].position=new BABYLON.Vector3(v[0], v[1], v[2]);
                this.reComputeESel(this.selectedF);
            }
            rotateFace(angle,scene) {
                if(this.selectedV<0||this.selectedF==null) return;
                let f=this.selectedF,v=this.points[f[this.selectedV]];
                let from=this.points[f[(this.selectedV+2)%3]],to=this.points[f[(this.selectedV+1)%3]];
                let base=BABYLON.Vector3.Zero().fromArray(vnormalize(vsub(to,from))),la=BABYLON.Vector3.Zero().fromArray(vsub(v,from));
                let rotQ=BABYLON.Matrix.RotationAxis(base,angle*Math.PI/180);
                la=BABYLON.Vector3.TransformCoordinates(la,rotQ);
                v[0]=la.x+from[0];
                v[1]=la.y+from[1];
                v[2]=la.z+from[2];
                
                this.updateVertex(v,f[this.selectedV],scene);
                this.VSelMeshes[this.selectedV].position=new BABYLON.Vector3(v[0], v[1], v[2]);
                this.reComputeESel(this.selectedF);
            }
            

            updateVertex(v,idx,scene) {
                let orig=this;
                this.faces.forEach((f,i)=>{
                    f.some( (pt,j)=>{
                        if(pt==idx) {
                            orig.faceMeshes[i].dispose();
                            this.createFaceMesh(f,i,scene);
                            return true;
                        }
                        return false;
                    });
                });
            }
            selectFace(f,scene) {
                if(this.VSelMeshes==null) {
                    this.VSelMeshes = [];
                    for(let k=0;k<10;++k) this.VSelMeshes.push(BABYLON.Mesh.CreateSphere("p"+k, 10, SphD, scene,true));
                
                    this.VSelMeshes.forEach((m,i)=>{
                        m.material = new BABYLON.StandardMaterial("material", scene);
                        m.actionManager =new BABYLON.ActionManager(scene);
                        let _t=this;
                        m.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickTrigger, 
                            function (evt) { _t.selectVertex(i,scene); }));
                    });
                }
                this.reComputeESel(f);
                for(let j=f.length;j<10;++j) {
                    this.VSelMeshes[j].isVisible = false;
                }
                this.selectedF=f;
                this.selectEdge(-1,scene);
                this.selectVertex(-1,scene);
                console.log("Selected "+f);
            }
            unselectFace(scene) {
                for(let j=0;j<10;++j) {
                    this.VSelMeshes[j].isVisible = false;
                }
                this.ESelMeshes.forEach(m=>m.dispose());
                this.ESelMeshes=[];
                this.selectedF=null;
                this.selectEdge(-1,scene);
                this.selectVertex(-1,scene); 
            }
            reComputeESel(f) {
                this.ESelMeshes.forEach(m=>m.dispose());
                this.ESelMeshes=[];
                for(let j=0;j<f.length;++j) {
                    let p= this.points[f[j]];
                    this.VSelMeshes[j].position = new BABYLON.Vector3(p[0], p[1], p[2]);
                    this.VSelMeshes[j].isVisible=true;                   
                    this.ESelMeshes.push(this.getEdgeCyl(f,j,scene));
                }
            }
            getEdgeCyl(f,edgeIdx,scene) {
                    let p1=new BABYLON.Vector3().fromArray(this.points[f[edgeIdx]]);
                    let p2=new BABYLON.Vector3().fromArray(this.points[f[(edgeIdx+1)%f.length]]);
                    let distance = BABYLON.Vector3.Distance(p1,p2 )-SphD;
                
                    let cylinder = BABYLON.MeshBuilder.CreateCylinder("cylinder", 
                        {height:distance, diameterTop:0.1, diameterBottom:0.1, tessellation:6, subdivisions:1}, scene);
                    cylinder.material = new BABYLON.StandardMaterial("material", scene);
                    cylinder.actionManager =new BABYLON.ActionManager(scene);
                    let _t=this;
                    cylinder.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickTrigger, 
                        function (evt) { _t.selectEdge(edgeIdx,scene); }));
                    let diff=p2.subtract(p1);
                    //position cylinder in between p1 and p2
                    cylinder.position = p1.add(diff.scale(0.5));              
                    // rotate as needed
                    let rot=BABYLON.Quaternion.Zero();
                    BABYLON.Quaternion.FromUnitVectorsToRef(new BABYLON.Vector3(0,1, 0), diff.normalize(),rot );
                    cylinder.rotationQuaternion=rot;
                    return cylinder;
            }
            selectVertex(i,scene) {
                this.VSelMeshes.forEach((m,idx)=> { m.material.diffuseColor=(i==idx?BABYLON.Color3.Yellow():BABYLON.Color3.White()); });
                this.selectedV=i;
                if(i>=0) console.log("Selected V"+this.selectedF[i]);
            }
            selectEdge(i,scene) {
                this.ESelMeshes.forEach((m,idx)=> { m.material.diffuseColor=(i==idx?BABYLON.Color3.Yellow():BABYLON.Color3.White()); });
                this.selectedE=i;
                
            }
            newFace(scene) {
                if(this.selectedE<0) return;
                let p1i=this.selectedF[this.selectedE], p2i=this.selectedF[(this.selectedE+1)%this.selectedF.length];
                let p1=new BABYLON.Vector3().fromArray(this.points[p1i]);
                let p2=new BABYLON.Vector3().fromArray(this.points[p2i]);
                if(this.findFacesContaining(p1i,p2i).length ==2) return; // edge already has 2 faces cannot add one
                let cam=scene.activeCamera.getForwardRay().direction;
                let base=p2.subtract(p1);
                let mid=p1.add(p2.subtract(p1).scale(0.5));
                //let lines = BABYLON.MeshBuilder.CreateLines("lines", { points:[mid,mid.add(cam)] }, scene);
                let newPt=mid.add(cam.applyRotationQuaternion(BABYLON.Quaternion.RotationAxis(base,120*Math.PI/180)).scale(0.707));
                //console.log(newPt);
                let newFace=[p2i,p1i,this.points.length];
                this.points.push([newPt.x,newPt.y,newPt.z]);
                this.faces.push(newFace);               
                this.createFaceMesh(newFace,this.faces.length-1,scene);
                this.selectFace(newFace,scene);
            }
            extendFace(scene) {
                if(this.selectedE<0) return;
                let p1i=this.selectedE, p2i=(this.selectedE+1)%f.length;
                let p1=new BABYLON.Vector3().fromArray(this.points[p1i]);
                let p2=new BABYLON.Vector3().fromArray(this.points[p2i]);

            }
            findFacesContaining(p1,p2) {
                let res=[];
                this.faces.forEach( (f,fidx)=>{
                    let hasp1=false,hasp2=false;
                    f.forEach(v=>{if(v==p1) hasp1=true; else if(v==p2) hasp2=true;});
                    if(hasp1 && hasp2) res.push(fidx);
                })
                return res;
            }
            closeFacefromV(scene) {
                if(this.selectedV <0) return;
                let curV=this.selectedF[this.selectedV];
                let fe=this.findFreeEdges(curV);
                if(fe.size != 2) return;
                let newFace=[curV];
                fe.forEach( v=> {newFace.push(v);});
                this.faces.push(newFace);               
                this.createFaceMesh(newFace,this.faces.length-1,scene);
                this.selectFace(newFace,scene);

            }
            findFreeEdges(v) {
                let s=new Set();
                this.faces.forEach( (f)=>{
                    f.some((vert,vIdx)=>{
                        if(vert==v) {
                            let prev=f[vIdx==0?f.length-1:vIdx-1];
                            let next=f[vIdx==f.length-1?0:vIdx+1];
                            if(s.has(prev)) { s.delete(prev);} else {s.add(prev);}
                            if(s.has(next)) { s.delete(next);} else {s.add(next);}
                            return true;
                        }
                        return false;
                    });
                });
                return s;
            }
            deleteFace(scene) {

                if(this.selectedF==null) return;
                let toBeDeleted=[];
                this.selectedF.filter(v=>{
                    let found=false;
                    top:
                    for(const f of this.faces) {
                        if(f != this.selectedF) {
                            for(const ov of f) { 
                                if(ov==v) {
                                    found=true
                                    break top;
                                }
                            }
                        }
                    }
                    if(!found) toBeDeleted.push(v);
                });
                let sel=this.faces.indexOf(this.selectedF);
                this.unselectFace(scene);               
                this.faces.splice(sel,1);
                this.faceMeshes[sel].dispose();
                this.faceMeshes.splice(sel,1);
                for(const v of toBeDeleted) this.delPt(v);
            }
            delPt(vIdx) {
                this.points.splice(vIdx,1);
                for(const f of this.faces) {
                    for(let i=0;i<f.length;++i) if(f[i]>vIdx) --f[i];
                }
            }

            isClosed() {
                const edges=new Set();
                let id=0;
                for(f of this.faces) {
                    id=getUid(f[0],f[f.length-1]);
                    if(edges.has(id)) edges.delete(id); else edges.add(id);
                    for(let i=0;i<f.length-2;++i) {
                        id=getUid(f[i],f[i+1]);
                        if(edges.has(id)) edges.delete(id); else edges.add(id);
                    } 
                }
                return edges.size ==0;

            }
            getUid(p1,p2) { if(p1>p2) return p1+65536*p2; else return p2+65536*p1;}

            getRot(f) {
                let v1=vsub(this.points[f[0]],this.points[f[1]]);
                let v2=vsub(this.points[f[2]],this.points[f[1]]);
                const n= vnormalize(vXprd(v1,v2));
                const fwd=vnormalize(vadd(v1,v2));
                return BABYLON.Quaternion.FromLookDirectionLH(BABYLON.Vector3.Zero().fromArray(fwd),BABYLON.Vector3.Zero().fromArray(n)).invert();
            }
            getFlatCoords() {
                let am=[],res=[];
                for(let f of this.faceMeshes) { const lam = f.clone(); lam.setEnabled(false); am.push(lam);}
                
                for(let i=0;i<this.faces.length;++i) {
                    res[i]=[];
                    let f=this.faces[i];
                    am[i].rotationQuaternion = this.getRot(f);
                    let c=[0,0,0];
                    for(let p of f) c=vadd(c,this.points[p]);
                    c= smult(-1/f.length,c);
                    let wm=new BABYLON.Matrix();
                    wm= am[i].computeWorldMatrix(false);
                    am[i].position=BABYLON.Vector3.TransformCoordinates(BABYLON.Vector3.Zero().fromArray(c),wm);
                    wm=am[i].computeWorldMatrix(false);
                    //console.log(">>"+this.faces[i]);
                    for(let p of this.faces[i]) {
                        let local_pos = BABYLON.Vector3.TransformCoordinates(BABYLON.Vector3.Zero().fromArray(this.points[p]),wm);
                        res[i].push(local_pos);
                        console.log(local_pos.x+","+local_pos.y+","+local_pos.z);
                        //let s=BABYLON.Mesh.CreateSphere("p"+p, 10, 0.05, scene,true);
                        //s.position = local_pos;

                    }
                    return res;
                }
            }
        }
        


        const createScene = function() {
            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3.Black;

            const alpha =  Math.PI/4;
            const beta = Math.PI/3;
            const radius = 8;
            const target = new BABYLON.Vector3(0, 0, 0);
            const camera = new BABYLON.ArcRotateCamera("Camera", alpha, beta, radius, target, scene);
            camera.inputs.attached.mousewheel.wheelPrecision=40;
            camera.attachControl(canvas, true);

            const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(1, 1, 0));

            const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 4, height: 4});
            const theGUI=new Ui(scene);
            theOrigami= new Origami(scene,[[0,0,0.5],[1,0,0.5],[0,1,0.5],[0,0,1.5]],[[0,1,2],[0,3,1],[0,2,3]]);
            
            return scene;

        };

        scene=createScene();
        engine.runRenderLoop(() => scene.render());
    </script>
</body>
</html>
